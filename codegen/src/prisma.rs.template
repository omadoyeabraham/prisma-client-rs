use std::sync::Arc;

use datamodel::\{parse_datamodel, parse_configuration, common::preview_features::PreviewFeature};
use query_core::\{BuildMode, QuerySchema, executor::QueryExecutor, exec_loader, schema_builder};
use prisma_models::DatamodelConverter;
use serde::\{de::DeserializeOwned, Serialize, Deserialize};
use juniper::GraphQLEnum;
use graphql_parser::parse_query;
use prisma_derive::QueryInternal;
use request_handlers::GraphQLProtocolAdapter;
use crate::\{serialization::to_query_args, Queryable};

// ====================== Enums ==========================

{{- for enum in enums }}
#[derive(Clone, PartialEq, Deserialize, Serialize, Debug, QueryInternal, GraphQLEnum)]
pub enum {enum.name} \{
	{{- for variant in enum.variants}}
	#[serde(rename = "{variant.actual}")]
	{variant.render | unescaped},
	{{- endfor}}
}
{{- endfor }}

{{- for enum in input_enums }}
#[derive(Clone, Debug, Serialize)]
#[serde(untagged)]
pub enum {enum.name} \{
	{{- for variant in enum.variants}}
	{{- if variant.rename }}
	#[serde(rename = "{variant.actual}")]
	{{- endif }}
	{variant.render | unescaped},
	{{- endfor}}
}
{{- endfor }}

// ======================================================================================

// ====================================== Input Types ===================================
{{- for struct in inputs }}
#[derive(Clone, Default, Serialize, Debug)]
pub struct {struct.name} \{
    {{- for field in struct.fields}}
    {{- if not field.is_required }}
    #[serde(skip_serializing_if = "Option::is_none")]
    {{- endif }}
    #[serde(rename = "{field.name.actual}")]
    pub {field.name.render}: {field.type | unescaped},
    {{- endfor }}
}
{{- endfor }}
// ======================================================================================

// ====================================== Output Types ===================================
{{- for struct in outputs }}
#[derive(Clone, Serialize, Deserialize, Debug, QueryInternal)]
pub struct {struct.name} \{
    {{- for field in struct.fields}}
    {{- if not field.is_required }}
    #[serde(skip_serializing_if = "Option::is_none")]
    {{- endif }}
    #[serde(rename = "{field.name.actual}")]
    pub {field.name.render}: {field.type | unescaped},
    {{- endfor }}
}
{{- endfor }}
// ======================================================================================


// ======================================= Argument Types ==========================================
{{- for operation in operations }}
{{- for struct in operation.input_types }}
#[derive(Clone, Default, Serialize, Debug)]
pub struct {struct.name} \{
    {{-for field in struct.fields}}
    {{-if not field.is_required }}
    #[serde(skip_serializing_if = "Option::is_none")]
    {{- endif }}
    pub {field.name.render}: {field.type | unescaped},
    {{-endfor}}
}
{{- endfor }}

{{- for enum in operation.input_enums }}
#[derive(Clone, Debug, Serialize)]
#[serde(untagged)]
pub enum {enum.name} \{
	{{- for variant in enum.variants}}
	{{- if variant.rename }}
	#[serde(rename = "{variant.actual}")]
	{{- endif }}
	{variant.render | unescaped},
	{{- endfor}}
}
{{- endfor }}
{{- endfor }}
// ============================================================================================

pub struct Prisma \{
	executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
	query_schema: Arc<QuerySchema>,
}

impl Prisma \{
	pub async fn new(preview_features: Vec<PreviewFeature>) -> Result<Self, Error> \{
		let datamodel_str = r###"{datamodel | unescaped}"###;
		let config = parse_configuration(datamodel_str)?.subject;
		let source = config.datasources.first()
			.expect("Please supply a datasource in your datamodel.prisma file");

		let model = parse_datamodel(datamodel_str)?.subject;
		let url = source.load_url()?;
		let (db_name, executor) = exec_loader::load(&source, &preview_features, &url).await?;

		let internal_model = DatamodelConverter::convert(&model).build(db_name);
		let query_schema = Arc::new(schema_builder::build(
			internal_model,
			BuildMode::Modern,
			true,
			source.capabilities(),
			preview_features
		));
		// verify connection
		executor.primary_connector().get_connection().await?;

		Ok(Self \{ executor, query_schema })
	}

	// TODO: support transactions.

	{{- for operation in operations }}
    {{- for method in operation.methods }}
    pub async fn {method.fn_name}<T>(&self, {method.fn_arg | unescaped}) -> Result<{ method.fn_return | unescaped}, Error>
        where
            T: Queryable + DeserializeOwned,
    \{
    	let mut operation_args = String::new();
        // for every query argument, insert it into the gql query.
        {{- for arg in method.query_args }}
    	{{- if not arg.is_required }}
        if {arg.name.render}.is_some() \{
        	operation_args.push_str(&format!(
        		"{arg.name.actual}: \{},",
        		to_query_args({arg.name.render}.as_ref().unwrap()).unwrap()
        	));
        }
        {{- else }}
        operation_args.push_str(&format!(
        	"{arg.name.actual}: \{},",
        	to_query_args(&{arg.name.render}).unwrap()
        ));
        {{- endif }}
    	{{- endfor }}

    	if !operation_args.is_empty() \{
    		operation_args = format!("(\{})", operation_args);
    	}
    	let query = format!(r#"{operation.name} \{\{ {method.query_name} \{} \{} }}"#,
    		operation_args,
    		T::query(),
    	);
    	let document = parse_query(&query)?;
    	log::debug!(target: "prisma-client", "\n\{}", document);
    	let schema = self.query_schema.clone();
		let operation = GraphQLProtocolAdapter::convert(document, None).unwrap();

    	let response = self.executor.execute(operation, schema).await?.data;

    	// TODO: implement Deserializer for `Item`
    	// let data = T::deserialize(response)
    	//     .expect("Validation is done by prisma_derive::Queryable, this is infallible"));
    	let value = serde_json::to_value(&response)
    		.expect("Deserializing to serde_json::Value should be infallible");
    	let data = serde_json::from_value(value)
    		.expect("Validation is done by prisma_client_derive::Queryable, this is infallible");
    	Ok(data)
    }
    {{- endfor }}
    {{- endfor }}
}

#[derive(derive_more::From, derive_more::Display, Debug)]
pub enum Error \{
	QueryError(query_core::error::CoreError),
	GraphqlParseError(graphql_parser::query::ParseError),
	QueryConnector(query_connector::error::ConnectorError),
	Datamodel(datamodel::diagnostics::Diagnostics),
	Other(String),
}
